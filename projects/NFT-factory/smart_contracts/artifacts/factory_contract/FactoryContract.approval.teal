#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 2
    bytecblock "totalMinted" 0x151f7c75 "creator"
    // smart_contracts/factory_contract/contract.algo.ts:16-17
    // @contract({ stateTotals: { globalUints: 32, globalBytes: 32 } })
    // export class FactoryContract extends Contract {
    txn NumAppArgs
    bz main_after_if_else@10
    pushbytess 0x9ff55d82 0x80664fac 0xd35e243f 0x40dbb26c // method "onCreate()void", method "mint_NFT(string,string,byte[])uint64", method "own_NFT(uint64,string)void", method "get_totalMinted()uint64"
    txna ApplicationArgs 0
    match main_onCreate_route@3 main_mint_NFT_route@4 main_own_NFT_route@5 main_get_totalMinted_route@6

main_after_if_else@10:
    // smart_contracts/factory_contract/contract.algo.ts:16-17
    // @contract({ stateTotals: { globalUints: 32, globalBytes: 32 } })
    // export class FactoryContract extends Contract {
    intc_0 // 0
    return

main_get_totalMinted_route@6:
    // smart_contracts/factory_contract/contract.algo.ts:66
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_totalMinted
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_own_NFT_route@5:
    // smart_contracts/factory_contract/contract.algo.ts:53
    // public own_NFT(assetId: uint64, name: string) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/factory_contract/contract.algo.ts:16-17
    // @contract({ stateTotals: { globalUints: 32, globalBytes: 32 } })
    // export class FactoryContract extends Contract {
    txna ApplicationArgs 1
    dup
    len
    pushint 8 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/factory_contract/contract.algo.ts:53
    // public own_NFT(assetId: uint64, name: string) {
    callsub own_NFT
    intc_1 // 1
    return

main_mint_NFT_route@4:
    // smart_contracts/factory_contract/contract.algo.ts:27
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/factory_contract/contract.algo.ts:16-17
    // @contract({ stateTotals: { globalUints: 32, globalBytes: 32 } })
    // export class FactoryContract extends Contract {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/factory_contract/contract.algo.ts:27
    // @abimethod()
    callsub mint_NFT
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_onCreate_route@3:
    // smart_contracts/factory_contract/contract.algo.ts:22
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub onCreate
    intc_1 // 1
    return


// smart_contracts/factory_contract/contract.algo.ts::FactoryContract.onCreate() -> void:
onCreate:
    // smart_contracts/factory_contract/contract.algo.ts:18
    // public creator = GlobalState<Account>({ key: 'creator' })
    bytec_2 // "creator"
    // smart_contracts/factory_contract/contract.algo.ts:24
    // this.creator.value = Txn.sender
    txn Sender
    app_global_put
    // smart_contracts/factory_contract/contract.algo.ts:20
    // public totalMinted = GlobalState<uint64>()
    bytec_0 // "totalMinted"
    // smart_contracts/factory_contract/contract.algo.ts:25
    // this.totalMinted.value = Uint64(0)
    intc_0 // 0
    app_global_put
    retsub


// smart_contracts/factory_contract/contract.algo.ts::FactoryContract.mint_NFT(name: bytes, url: bytes, metadata: bytes) -> uint64:
mint_NFT:
    // smart_contracts/factory_contract/contract.algo.ts:27-28
    // @abimethod()
    // public mint_NFT(name: string, url: string, metadata: bytes) {
    proto 3 1
    // smart_contracts/factory_contract/contract.algo.ts:29
    // assert(Txn.sender === this.creator.value, 'Non autorizzato')
    txn Sender
    // smart_contracts/factory_contract/contract.algo.ts:18
    // public creator = GlobalState<Account>({ key: 'creator' })
    intc_0 // 0
    bytec_2 // "creator"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/factory_contract/contract.algo.ts:29
    // assert(Txn.sender === this.creator.value, 'Non autorizzato')
    ==
    assert // Non autorizzato
    // smart_contracts/factory_contract/contract.algo.ts:31-45
    // const itxn_result = itxn
    //   .assetConfig({
    //     total: 1,
    //     decimals: 0,
    //     unitName: 'NFT',
    //     assetName: name,
    //     url: url,
    //     metadataHash: metadata,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.currentApplicationAddress,
    //     clawback: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/factory_contract/contract.algo.ts:39
    // manager: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/factory_contract/contract.algo.ts:40-42
    // reserve: Global.currentApplicationAddress,
    // freeze: Global.currentApplicationAddress,
    // clawback: Global.currentApplicationAddress,
    dupn 3
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    frame_dig -1
    itxn_field ConfigAssetMetadataHash
    frame_dig -2
    itxn_field ConfigAssetURL
    frame_dig -3
    itxn_field ConfigAssetName
    // smart_contracts/factory_contract/contract.algo.ts:35
    // unitName: 'NFT',
    pushbytes "NFT"
    itxn_field ConfigAssetUnitName
    // smart_contracts/factory_contract/contract.algo.ts:34
    // decimals: 0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    // smart_contracts/factory_contract/contract.algo.ts:33
    // total: 1,
    intc_1 // 1
    itxn_field ConfigAssetTotal
    // smart_contracts/factory_contract/contract.algo.ts:31-44
    // const itxn_result = itxn
    //   .assetConfig({
    //     total: 1,
    //     decimals: 0,
    //     unitName: 'NFT',
    //     assetName: name,
    //     url: url,
    //     metadataHash: metadata,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.currentApplicationAddress,
    //     clawback: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    pushint 3 // 3
    itxn_field TypeEnum
    // smart_contracts/factory_contract/contract.algo.ts:43
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/factory_contract/contract.algo.ts:31-45
    // const itxn_result = itxn
    //   .assetConfig({
    //     total: 1,
    //     decimals: 0,
    //     unitName: 'NFT',
    //     assetName: name,
    //     url: url,
    //     metadataHash: metadata,
    //     manager: Global.currentApplicationAddress,
    //     reserve: Global.currentApplicationAddress,
    //     freeze: Global.currentApplicationAddress,
    //     clawback: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/factory_contract/contract.algo.ts:20
    // public totalMinted = GlobalState<uint64>()
    intc_0 // 0
    bytec_0 // "totalMinted"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/factory_contract/contract.algo.ts:48
    // this.totalMinted.value = total + Uint64(1)
    intc_1 // 1
    +
    // smart_contracts/factory_contract/contract.algo.ts:20
    // public totalMinted = GlobalState<uint64>()
    bytec_0 // "totalMinted"
    // smart_contracts/factory_contract/contract.algo.ts:48
    // this.totalMinted.value = total + Uint64(1)
    swap
    app_global_put
    // smart_contracts/factory_contract/contract.algo.ts:49
    // GlobalState<uint64>({ key: name }).value = itxn_result.createdAsset.id
    frame_dig -3
    dig 1
    app_global_put
    // smart_contracts/factory_contract/contract.algo.ts:50
    // return itxn_result.createdAsset.id
    retsub


// smart_contracts/factory_contract/contract.algo.ts::FactoryContract.own_NFT(assetId: uint64, name: bytes) -> void:
own_NFT:
    // smart_contracts/factory_contract/contract.algo.ts:53
    // public own_NFT(assetId: uint64, name: string) {
    proto 2 0
    // smart_contracts/factory_contract/contract.algo.ts:54-61
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId,
    //     assetReceiver: Txn.sender,
    //     assetAmount: 1,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/factory_contract/contract.algo.ts:57
    // assetReceiver: Txn.sender,
    txn Sender
    // smart_contracts/factory_contract/contract.algo.ts:58
    // assetAmount: 1,
    intc_1 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -2
    itxn_field XferAsset
    // smart_contracts/factory_contract/contract.algo.ts:54-60
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId,
    //     assetReceiver: Txn.sender,
    //     assetAmount: 1,
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/factory_contract/contract.algo.ts:59
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/factory_contract/contract.algo.ts:54-61
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId,
    //     assetReceiver: Txn.sender,
    //     assetAmount: 1,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/factory_contract/contract.algo.ts:63
    // GlobalState<uint64>({ key: name }).delete()
    frame_dig -1
    app_global_del
    retsub


// smart_contracts/factory_contract/contract.algo.ts::FactoryContract.get_totalMinted() -> uint64:
get_totalMinted:
    // smart_contracts/factory_contract/contract.algo.ts:20
    // public totalMinted = GlobalState<uint64>()
    intc_0 // 0
    bytec_0 // "totalMinted"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/factory_contract/contract.algo.ts:68
    // return this.totalMinted.value
    retsub
